' Project: Visio Diagram Generator (VDG)
' Purpose: High‑level pseudocode skeleton — REFACTORED with explicit **No‑Connectors‑Stencil** rule
' Language‑agnostic VB‑style pseudocode illustrating strong typing, error handling,
' immutable models, COM safety, and test‑friendly boundaries.
'
' Each module corresponds to a source file in the repository.
' Replace guide‑post comments with production code.

Option Explicit On

' =============================================================================
' 0. Pinned Rule — **No CONNECTORS Stencil**
' =============================================================================
' We never load a connectors stencil (e.g., CONNECTORS_U.VSSX). Edges are created
' using Visio's built‑in Connector Tool object and glued to shapes. This improves:
'   • Stability — avoids ActiveDocument switching & NameU drift between Visio builds.
'   • Performance — no extra stencil document; fewer COM round‑trips.
'   • Determinism — routing/glue are explicit; behavior is testable.
'
' Implementation sketch:
'   connector = ActivePage.Drop(Application.ConnectorToolDataObject, x:=0, y:=0)
'   connector.CellsU("BeginX").GlueTo( fromShape.CellsU("PinX") )  ' to shape pin
'   connector.CellsU("EndX").GlueTo(   toShape.CellsU("PinX")   )
'   ' Optional: choose specific connection points (N/E/S/W) before glue:
'   '   fromShape.CellsU("Connections.X1"), .Y1, etc., or a policy that maps sides
'   ' Optional: re‑route for cleanliness, then style via cell formulas
'
' Test affordances:
'   • Ensure **no** stencil named like /CONNECTORS/i is opened (CommandLog assertion).
'   • Verify Draw order = [all shapes] → [all connectors].
'   • Verify each connector has Begin/End glued (GlueInfo non‑null) and nonzero geometry.
'
' =============================================================================
' 1. Configuration & Validation
' =============================================================================
Module DiagramConfig
    Public Property Layout As String = "grid"
    Public Property ExportFormat As String = ExportFormat.Png
    Public Property PageWidth As Double = 8.5   ' inches
    Public Property PageHeight As Double = 11.0
    Public Property Version As Integer = 1
    ' Connector policy (optional): "pin" | "sided(N|E|S|W)" | "auto"
    Public Property ConnectorPolicy As String = "pin"
End Module

Module ConfigLoader
    Function LoadConfig(path As String) As DiagramConfig
        Try
            Dim json As String = File.ReadAllText(path)
            Dim cfg As DiagramConfig = Json.Deserialize(Of DiagramConfig)(json)
            Return ValidateConfig(cfg)
        Catch ex As Exception
            Logging.LogError($"Config load failed: {ex.Message}")
            Throw
        End Try
    End Function

    Private Function ValidateConfig(cfg As DiagramConfig) As DiagramConfig
        If String.IsNullOrWhiteSpace(cfg.Layout) Then cfg.Layout = "grid"
        If cfg.PageWidth <= 0 OrElse cfg.PageHeight <= 0 Then
            Throw New ArgumentException("Page size must be positive.")
        End If
        If String.IsNullOrWhiteSpace(cfg.ConnectorPolicy) Then cfg.ConnectorPolicy = "pin"
        Return cfg
    End Function
End Module

' =============================================================================
' 1a. Page Sizing Policy (Generate-first defaults)
' =============================================================================
' Users rarely want to tweak print sizes; the primary expectation is that a diagram
' will **always generate**, regardless of size. We therefore:
'   • Default to an **autosizing page** (page grows to content).
'   • Treat explicit page width/height as optional overrides.
'   • Provide a "fit-to-one-page" switch for export-only scenarios.
'
' Config surface (plain language):
'   PageSizingMode: "auto" (default) | "fixed" | "fit-one-page"
'   PageWidthIn, PageHeightIn: optional numbers (required only when mode = fixed)
'
' Runtime behavior:
'   • auto: enable page autosize before drawing; no print constraints block generation.
'   • fixed: create page with the given dimensions; still generate even if content exceeds.
'   • fit-one-page: draw normally, then apply a "shrink to fit" transform for export/print.
'
' Validation:
'   • If mode = fixed and width/height are missing or <= 0 → validation error.
'   • Otherwise, widths/heights are **not required**.

' =============================================================================
' 2. Domain Models (Immutable Records)
' =============================================================================
Public Class DiagramItem
    Public ReadOnly Property Id As String
    Public ReadOnly Property TypeName As String
    Public ReadOnly Property Label As String
    Public ReadOnly Property X As Double
    Public ReadOnly Property Y As Double
    Public Sub New(id$, typeName$, label$, x#, y#)
        Me.Id = id : Me.TypeName = typeName : Me.Label = label : Me.X = x : Me.Y = y
    End Sub
End Class

Public Class DiagramConnection
    Public ReadOnly Property SourceId As String
    Public ReadOnly Property TargetId As String
    Public ReadOnly Property ConnectorType As String
    ' Pinned rule surfaced here for test visibility / future policy config
    Public ReadOnly Property UsesConnectorTool As Boolean = True  ' always True under No‑Stencil rule
    Public Sub New(src$, trg$, connType$)
        SourceId = src : TargetId = trg : ConnectorType = connType
    End Sub
End Class

' =============================================================================
' 3. Utilities
' =============================================================================
Module Logging
    Sub LogInfo(msg$) : Console.WriteLine($"[INFO] {DateTime.Now:u} {msg}") : End Sub
    Sub LogWarn(msg$) : Console.WriteLine($"[WARN] {DateTime.Now:u} {msg}") : End Sub
    Sub LogError(msg$) : Console.WriteLine($"[ERR ] {DateTime.Now:u} {msg}") : End Sub
End Module

Module ComSafety
    <Extension>
    Sub SafeRelease(Of T)(ByRef comObj As T)
        Try
            If comObj IsNot Nothing AndAlso Marshal.IsComObject(comObj) Then
                Marshal.FinalReleaseComObject(comObj)
            End If
        Finally
            comObj = Nothing
        End Try
    End Sub
End Module

' =============================================================================
' 4. Providers (Strongly‑Typed Interfaces)
' =============================================================================
Public Interface IMapProvider
    Function GetItems() As IReadOnlyList(Of DiagramItem)
    Function GetConnections() As IReadOnlyList(Of DiagramConnection)
End Interface

' Example provider with exception safety
Public Class CallSiteMapProvider : Implements IMapProvider
    Public Function GetItems() As IReadOnlyList(Of DiagramItem) Implements IMapProvider.GetItems
        Dim items = New List(Of DiagramItem)
        Try
            For Each cs In RegexCallScanner.ScanProject()
                items.Add(New DiagramItem(Guid.NewGuid().ToString(), "CallSite", $"{cs.Caller}->{cs.Callee}", 0, 0))
            Next
        Catch ex As Exception
            Logging.LogError($"CallSite provider failed: {ex.Message}")
        End Try
        Return items
    End Function

    Public Function GetConnections() As IReadOnlyList(Of DiagramConnection) Implements IMapProvider.GetConnections
        Return New List(Of DiagramConnection)() ' Build connections here
    End Function
End Class

' =============================================================================
' 5. Layout Algorithms (Functional Style)
' =============================================================================
Public Interface ILayoutAlgorithm
    Function Compute(items As IReadOnlyList(Of DiagramItem),
                     conns As IReadOnlyList(Of DiagramConnection)) As IReadOnlyList(Of DiagramItem)
End Interface

Public Class GridLayoutAlgorithm : Implements ILayoutAlgorithm
    Public Function Compute(items As IReadOnlyList(Of DiagramItem),
                            conns As IReadOnlyList(Of DiagramConnection)) As IReadOnlyList(Of DiagramItem) _
                            Implements ILayoutAlgorithm.Compute
        Dim result = New List(Of DiagramItem)
        Dim cols = Math.Ceiling(Math.Sqrt(items.Count))
        For i = 0 To items.Count - 1
            Dim row = i \ cols
            Dim col = i Mod cols
            Dim itm = items(i)
            result.Add(New DiagramItem(itm.Id, itm.TypeName, itm.Label, col * 2, row * 2))
        Next
        Return result
    End Function
End Class

' =============================================================================
' 6. VisioService (COM Interop Encapsulated)
' =============================================================================
Public Interface IVisioService : Inherits IDisposable
    Function DrawShape(master$, x#, y#, label$) As String
    Sub DrawConnector(srcId$, trgId$, connType$, Optional policy$ = "pin")
    Sub EnsureDocumentAndPage()
    Sub OpenStencilHiddenReadOnly(nameOrPath$) ' caches in memory; never steals focus
End Interface

Public Class VisioServiceImpl : Implements IVisioService
    Private ReadOnly _app As Visio.Application
    Private ReadOnly _page As Visio.Page
    Private ReadOnly _shapeIndex As New Dictionary(Of String, Visio.Shape)(StringComparer.OrdinalIgnoreCase)
    Private ReadOnly _stencilCache As New Dictionary(Of String, Visio.Document)(StringComparer.OrdinalIgnoreCase)

    Public Sub New()
        _app = New Visio.Application()
        _page = _app.ActivePage
    End Sub

    Public Sub EnsureDocumentAndPage() Implements IVisioService.EnsureDocumentAndPage
        ' Ensure a drawing doc and active page exist before any draw calls
        ' (Create if necessary; never rely on a stencil becoming ActiveDocument)
    End Sub

    Public Sub OpenStencilHiddenReadOnly(nameOrPath$) Implements IVisioService.OpenStencilHiddenReadOnly
        ' If not already cached, open as hidden+read‑only and store in _stencilCache
        ' Do NOT modify ActiveDocument
    End Sub

    Public Function DrawShape(master$, x#, y#, label$) As String Implements IVisioService.DrawShape
        ' Look up master in cached stencils or the document; drop and index by logical id
        Dim sid = Guid.NewGuid().ToString()
        ' ... drop master, set text, etc.
        _shapeIndex(sid) = Nothing ' placeholder for the dropped Visio.Shape
        Return sid
    End Function

    Public Sub DrawConnector(srcId$, trgId$, connType$, Optional policy$ = "pin") Implements IVisioService.DrawConnector
        ' ===== No‑Stencil rule in action =====
        ' Create a connector via Application.ConnectorToolDataObject instead of loading CONNECTORS stencil
        Dim connector As Visio.Shape = _page.Drop(_app.ConnectorToolDataObject, 0, 0)

        Dim fromShape = _shapeIndex(srcId$)
        Dim toShape   = _shapeIndex(trgId$)

        If fromShape Is Nothing OrElse toShape Is Nothing Then
            Throw New InvalidOperationException("Connector endpoints must exist before wiring.")
        End If

        ' Choose glue targets per policy
        Select Case policy$.ToLowerInvariant()
            Case "pin"
                connector.CellsU("BeginX").GlueTo(fromShape.CellsU("PinX"))
                connector.CellsU("EndX").GlueTo(  toShape.CellsU("PinX"))
            Case "sided-n", "sided-e", "sided-s", "sided-w"
                ' Example: pick a specific Connections.Xn/Yn before gluing (pseudo)
                ' Dim (cxFrom, cyFrom) = ConnectionPointSelector.Select(fromShape, policy$)
                ' Dim (cxTo,   cyTo)   = ConnectionPointSelector.Select(toShape,   policy$)
                ' connector.CellsU("BeginX").GlueTo(fromShape.CellsU(cxFrom))
                ' connector.CellsU("EndX").GlueTo(  toShape.CellsU(cyTo))
            Case Else
                ' Default to pin if unknown
                connector.CellsU("BeginX").GlueTo(fromShape.CellsU("PinX"))
                connector.CellsU("EndX").GlueTo(  toShape.CellsU("PinX"))
        End Select

        ' Optional tidy‑up: trigger routing and basic style
        ' connector.AutoConnect(...) or connector.Layout
        ' SetLinePattern/Arrow if needed via cell formulas
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
        ' Release page, then app
        _page.SafeRelease()
        _app.Quit() : _app.SafeRelease()
    End Sub
End Class

' =============================================================================
' 7. Pipeline (Pure Core Orchestration)
' =============================================================================
Public Class Pipeline
    Private ReadOnly _providers As IReadOnlyList(Of IMapProvider)
    Private ReadOnly _layout As ILayoutAlgorithm
    Public Sub New(providers As IReadOnlyList(Of IMapProvider), layoutAlg As ILayoutAlgorithm)
        _providers = providers : _layout = layoutAlg
    End Sub
    Public Function BuildCommands() As IReadOnlyList(Of DrawCommand)
        Dim allItems = _providers.SelectMany(Function(p) p.GetItems()).ToList()
        Dim allConns = _providers.SelectMany(Function(p) p.GetConnections()).ToList()
        Dim positioned = _layout.Compute(allItems, allConns)
        Return CommandFactory.From(positioned, allConns)
    End Function
End Class

Public Class DrawCommand
    Public ReadOnly Property Kind As String
    Public ReadOnly Property Data As Object
    Public Sub New(kind$, data As Object)
        Me.Kind = kind : Me.Data = data
    End Sub
End Class

Module CommandFactory
    Function From(items As IReadOnlyList(Of DiagramItem),
                  conns As IReadOnlyList(Of DiagramConnection)) As IReadOnlyList(Of DrawCommand)
        Return items.Select(Function(i) New DrawCommand("shape", i)).Concat(
               conns.Select(Function(c) New DrawCommand("connector", c))).ToList()
    End Function
End Module

' =============================================================================
' 8. DiagramBuilder (Executes Commands against Visio)
' =============================================================================
Public Class DiagramBuilder
    Private ReadOnly _visio As IVisioService
    Private ReadOnly _policy As String
    Public Sub New(vs As IVisioService, Optional connectorPolicy$ = "pin")
        _visio = vs : _policy = connectorPolicy$
    End Sub

    Public Sub Execute(cmds As IReadOnlyList(Of DrawCommand))
        ' Draw shapes first
        For Each cmd In cmds.Where(Function(c) c.Kind = "shape")
            Dim itm = CType(cmd.Data, DiagramItem)
            _visio.DrawShape(ShapeMapping.GetMaster(itm.TypeName), itm.X, itm.Y, itm.Label)
        Next
        ' Then connectors — **No stencil**: uses ConnectorToolDataObject internally
        For Each cmd In cmds.Where(Function(c) c.Kind = "connector")
            Dim cn = CType(cmd.Data, DiagramConnection)
            _visio.DrawConnector(cn.SourceId, cn.TargetId, cn.ConnectorType, _policy)
        Next
    End Sub
End Class

' =============================================================================
' 9. Top‑Level Generation Entry
' =============================================================================
Module DiagramGenerator
    Sub Run(cfgPath$, sourceRoot$, outputFile$)
        Dim cfg = ConfigLoader.LoadConfig(cfgPath)
        Dim providers = {New CallSiteMapProvider()}.ToList()
        Dim pipeline = New Pipeline(providers, New GridLayoutAlgorithm())
        Dim cmds = pipeline.BuildCommands()
        Using vs As New VisioServiceImpl()
            vs.EnsureDocumentAndPage()
            ' Load needed shape stencils hidden + read‑only (never CONNECTORS)
            ' vs.OpenStencilHiddenReadOnly("Basic Shapes.vssx")
            Dim builder = New DiagramBuilder(vs, connectorPolicy:=cfg.ConnectorPolicy)
            builder.Execute(cmds)
            ' Export via Visio API...
        End Using
    End Sub
End Module
